  # Lion, Goat, and Cabbage River Crossing Problem
The code solves the classic Lion, Goat, and Cabbage river crossing problem using three search algorithms:<br/>

Breadth-First Search (BFS)<br/>
Depth-First Search (DFS)<br/>
Depth-First Iterative Deepening (DFID)<br/>


In this problem, the boatman has to take the Lion, Goat, and Cabbage from one side of the river to the other. However, there are certain constraints:<br/>

If the Lion and Goat are left alone without the boatman, the Lion will eat the Goat.<br/>
If the Goat and Cabbage are left alone without the boatman, the Goat will eat the Cabbage.<br/>
The task is to find a way for the boatman to move all three safely to the other side of the river.<br/>

## State Representation
Each state is represented by a 4-element list:<br/>

The first element represents the Lion's position (0 for the left bank, 1 for the right bank).<br/>
The second element represents the Goat's position (0 for the left bank, 1 for the right bank).<br/>
The third element represents the Cabbage's position (0 for the left bank, 1 for the right bank).<br/>
The fourth element represents the Boatman's position (0 for the left bank, 1 for the right bank).<br/>

  ## Helper Functions
### verfication(node)
Purpose: Checks if the given state is valid, i.e., the Lion and Goat or Goat and Cabbage are not together without the Boatman.<br/>
Arguments:<br/>
node: The current state.<br/>
Returns: True if the state is valid, otherwise False.<br/>

### MoveGen(node)<br/>
Purpose: Generates all valid possible moves from the current state. The Boatman can take himself alone or with one item (Lion, Goat, or Cabbage) across the river.<br/>
Arguments:<br/>
node: The current state.<br/>
Returns: A list of new valid states generated by moving the Boatman.<br/>

### Makepairs(NewNode, NodePair)
Purpose: Creates pairs of the new nodes with their parent node for tracking the path.<br/>
Arguments:<br/>
NewNode: List of new nodes generated after a move.<br/>
NodePair: The current node, which acts as the parent of the new nodes.<br/>
Returns: A list of pairs, where each new node is paired with its parent.<br/>

### RemoveSeen(Closed, children)<br/>
Purpose: Filters out nodes that have already been visited (i.e., nodes present in the Closed list) from the list of newly generated nodes.<br/>
Arguments:<br/>
Closed: The list of nodes that have been visited.<br/>
children: List of new nodes generated by MoveGen.<br/>
Returns: A list of nodes that haven't been visited.<br/>

## Search Algorithms
### db_dfs(OpenNode, GoalNode, depth)
Purpose: Performs depth-bounded DFS. It searches for the goal node while limiting the depth of the search.<br/>
Arguments:<br/>
OpenNode: The starting state.<br/>
GoalNode: The goal state (all items on the other side of the river).<br/>
depth: The current depth limit for the search.<br/>
Returns: The path to the goal node if found, otherwise returns an empty list.<br/>
### DFID(OpenNode, GoalNode)
Purpose: Implements Depth-First Iterative Deepening (DFID) by calling depth-bounded DFS with increasing depth until the goal state is found.<br/>
Arguments:<br/>
OpenNode: The starting state.<br/>
GoalNode: The goal state.<br/>
Returns: The path to the goal node if found.<br/>
### DFS(OpenNode, GoalNode)
Purpose: Implements Depth-First Search (DFS).<br/>
Arguments:<br/>
OpenNode: The starting state.<br/>
GoalNode: The goal state.<br/>
Returns: The path to the goal node if found, otherwise returns an empty list.<br/>
### BFS(OpenNode, GoalNode)
Purpose: Implements Breadth-First Search (BFS).<br/>
Arguments:<br/>
OpenNode: The starting state.<br/>
GoalNode: The goal state.<br/>
Returns: The path to the goal node if found, otherwise returns an empty list.<br/>
